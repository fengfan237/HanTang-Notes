
<br>

<div align="center">
    <img src="logo.jpg" width="200px">
</div>

<br>

1.	**操作系统的基本特征：**
(1)	并发：并发指的是宏观上在一段时间内同时运行多个程序，而并行指的是同一时刻能运行多个指令。并行需要硬件支持，如多流水线，多核处理器或者分布式计算系统。操作系统通过引入进程和线程使得程序能够并发运行。
(2)	共享：指的是系统中的资源可以被多个并发进程共同使用，主要有两种共享方式，互斥共享和同时共享，互斥共享的资源被称为临界资源，例如打印机，在同一时刻只允许一个进程访问，他需要同步机制来实现互斥访问。
(3)	虚拟：虚拟技术把一个物理实体转换为多个逻辑实体，主要的虚拟技术为时分复用和空分复用。多进程在同一个处理器上处理是使用了时分复用技术，他让每个进程轮流占用处理器，每次只执行一个小的时间片并快速切换。虚拟内存使用的是空分复用技术，它能将物理内存抽象为地址空间，每个进程都有各自的地址空间，地址空间的页被映射到物理内存，地址空间的页并不需要全部在内存中，当使用到一个不存在物理内存的页的时候，会执行页面置换算法从物理磁盘中置换到内存中。
(4)	异步：进程并非一次性执行完毕，而是走走停停，以不可知的速度向前推进。
2.	**操作系统的基本功能：**
(1)	进程管理：进程同步，进程通信，死锁处理，处理器调度
(2)	内存管理：内存分配，地址映射，内存保护与共享，虚拟内存
(3)	文件管理：文件存储空间的管理，目录管理文件读写管理等
(4)	设备管理：IO请求，主要包括缓冲管理，设备分配，设备处理等
3.	**系统调用**
如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而进入内核态，由操作系统代为完成。
主要调用分为以下几类：进程控制（fork,exit），进程通信(pipe,mmap)，文件操作(open,read),设备操作等
4.	**进程与线程的状态：**
a)	进程的状态：就绪（当进程已经被分配到除了cpu以外所有的必要的资源的时候，这时候就被成为就绪状态），执行状态(指的是就绪状态的进程被分配到处理机以后进入的状态)，阻塞状态（运行状态产生信号，IO）
b)	线程的状态：java中线程主要有new, runnable(ready,running),terminated,time waiting,waiting, blocked. waiting(进入等待状态，主要是wait,join,park方法进入，notify/notify all/unpark接触)，time waiting指的是指定timeout的那三种wait方法。block指的是进入关键字Synchronized块。
5.	**进程详解**
(1)	进程由程序，数据以及进程控制块PCB是一个名为task_struct的结构体，PCB是进程的唯一标识，PCB之间由双向链表连接在一起主要是为了动态的插入和删除。进程创建的时候，会为该进程创建一个PCB，进程终止的时候则回收PCB。每个进程都有一个唯一的PID，这个PID是唯一的，但是可以被重用，当一个进程终止后，其他进程就可以使用这个PID。通常来说，PID为0的进程是调度进程，也叫作系统进程。PID为1的是init进程，它以超级用户特权运行，PID为2的是页守护进程，负责虚拟存储系统的分页操作。PCB中还包含gid(组ID)，uid(用户ID)。
(2)	进程的状态：就绪，运行和阻塞，创建即就绪，调度则运行，时间片用完则就绪，IO则阻塞
(3)	进程的创建实质是复制，它复制父进程中PCB的内容，再修改部分数据，分配新的内核堆栈，pid，之后再将这个PCB添加到链表中。子进程刚开始的时候，内核并不会为他分配物理内存，而是以只读的方式共享父进程内存，直到子进程写的时候才复制，即copy on write。
(4)	fork函数调用子进程，返回两次，父进程返回子进程pid，子进程返回pid为0.实质可以根据PID不同设计不同的处理代码。一般来说，父进程fork子进程之后，顺序执行是不确定的，取决于内核的调度算法。
(5)	vfork：与fork返回值相同，但是它不会复制父进程的数据空间，堆栈，它与父进程内存共享，它存在的意义主要是进行exec，一般是子进程调用Exit或exec之后，父进程才会继续往下执行
(6)	僵尸进程：主要指的是子进程先于父进程执行结束，父进程还没来得及回收子进程的信息，这时候子进程会变为僵尸进程。僵尸进程只保留task_struct这个结构体和栈空间。父进程可以使用wait或者waitpid回收子进程。
(7)	孤儿进程：父进程先与子进程结束，子进程变为一个孤儿进程。所有孤儿进程自动变为pid为1的进程的子进程。使用ps命令，Z标记的是僵尸进程。
(8)	wait和waitPID：主要是使父进程阻塞，等待子进程退出。waitpid正常返回子进程号，调用出错则返回-1。
(9)	exec函数：他的主要作用是能调用并执行一个可执行文件。子进程可以直接调用并执行这个可执行程序。execcl和execv。
(10)	System函数=fork+exec
(11)	守护进程，是后台服务进程，它的生存周期较长，没有控制终端，无法输出显示，它的父进程是init进程。
(12)	进程之间的通信（IPC）：管道，信号量，消息队列，共享内存，信号，socket
(13)	管道（有名管道和无名管道）：管道实际上是内核维护的一块内存，只不过有名管道表现的形式是一个有名字的文件，一个进程读，一个进程写。所以可以用于任意两个进程之间，无名管道只能用于有亲缘关系的进程之间。他们都是半双工的。
6.	**进程通信的目的：**数据传输，资源共享，数据共享，进程控制。
7.	**进程同步机制：**原子操作，信号量，分布式系统

8.	**线程详解**
是CPU调度的基本单位，一个标准的线程由线程ID，当前指令指针PC，寄存器集合以及堆栈组成。但是堆属于多个线程共享。一个进程由多个线程组成，各个线程之间共享程序的内存空间。包括代码段，数据段堆等
9.	**进程与线程的区别**
进程：管道通信（有名管道和无名管道，有名管道可以实现任意进程之间的通信而无名管道只能在具备亲缘关系的进程之间使用）。信号量机制，消息队列，共享内存（由一个进程创建但多个进程可以访问），还有socket通信。
	线程：可以通过锁机制通信，互相限制（互斥锁，读写锁，条件变量），信号量机制，barrier（允许所有线程等待直到所有的合作线程都达到某一点），信号（通过通知操作的方式来实现多线程同步）。
10.	线程同步方法：
a)	事件：一个线程执行完毕后，主动去唤醒另外一个线程执行任务、
b)	互斥量：与临界区对象很像，但是互斥量允许用在不同进程之间。
c)	信号量：需要一个计数器来限制，最大使用量。
11.	**缓冲区溢出**
导致程序崩溃或者跳转并执行一段恶意代码。
进程与线程之间私有和共享的资源：
	进程私有的：地址空间，堆，栈，寄存器以及全局变量。线程私有的：线程栈，寄存器和程序计数器。
	进程共享的：代码段，公共数据，进程目录和ID。线程共享的：堆，栈，地址空间，全局变量以及静态变量。
代码设计难度上… 线程占据优势的主要是在CPU利用上。
Linux内核的同步方式：主要是在多处理器系统上，也需要一些同步机制来同步不同处理器上的执行单元对共享数据的访问。主要方法有，原子操作，信号量机制，读写信号量，读写锁，顺序锁。
12.	**进程调度算法：**批处理系统（先来先服务，短作业优先，最短剩余时间优先算法），交互式系统（时间片，优先级调度，多级反馈队列）
13.	**死锁**
(1)	为什么会产生死锁？互斥，请求与保持，不可抢占，环路等待
(2)	处理方法：
a)	鸵鸟策略：由于出现死锁的概率较低并且处理死锁的代价较高。因此很多操作系统会忽略死锁。
b)	死锁检测与死锁恢复：不会阻止死锁，而是检测到死锁之后，进行恢复。对于每种类型资源只有一个的情况，可以判断有向图是不是存在环来判断。死锁恢复：主要有利用抢占恢复，利用回滚恢复或者杀死进程
c)	死锁预防：主要是对上面四个条件的打破，例如破坏互斥，即资源允许多个进程同时访问，在进程运行之前分配所有资源，给资源编号，按序执行。
d)	死锁避免：主要是银行家算法。
14.	**虚拟内存**
15.	**内核态与用户态**
**内核态：**CPU可以访问内存中的所有数据，包括外围设备，例如硬盘，网卡，CPU也可以将自己从一个程序切换到另外一个程序。
**用户态：**只能受限的访问内存，且不允许访问外围设备
为什么要有内核态与用户态？防止程序之间互相访问，获取其他程序的内存数据，并发送到网络。于此同时也是对一些重要内存和操作系统的保护。
用户态到内核态的机制是系统调用，系统调用是用户空间访问内核空间的唯一手段。系统调用：用户控件执行一个系统调用，他们不能直接调用内核中的内核函数，因为内核处于受保护的地址控制，不允许被进程访问，通过产生一个软中断，来触发一个可控的异常事件，这个事件会导致处理器切换到内核态并跳转到一个新地址并开始执行这个新地址的异常处理程序，用户控件请求的系统调用，首先会去查找一个系统调用号，并将这个系统调用号传给寄存器，如果是带参数，参数也要传给寄存器。这个寄存器中的数值会被传递给内核空间的处理事件，查找内核空间调用表，并执行对应的程序。
16.	**陷入、异常与中断**
中断：一般由CPU外部产生，例如IO，对CPU来说是被动的。当中断发生的时候，CPU会将要执行的下一条指令压栈作为中断服务的返回地址。
陷入：CPU本身在执行程序的过程中产生的，是程序有意产生，例如用户态到内核态的切换。它也会将下一条指令压栈作为返回地址。
异常：由于CPU无法完成一些指令导致的，例如除以0，IO失败这种。当异常发生的时候，CPU会将当前指令的地址压入栈，这样异常处理完后可以继续处理当前指令。
17.	**select, poll, epoll主要是epoll**
Select:首先使用copy_from_user从用户控件拷贝fd_set到内核空间，之后注册回调函数_pollwait，遍历所有的fd，并调用其对应的poll方法，poll方法返回的时候会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。如果遍历完所有的fd，还没有返回一个可读写的mask，就会调用schedule_timeout进入睡眠，当设备驱动发生自身资源可读写后会唤醒其等待队列上睡眠的进程，如果超过timeout还没被唤醒，则就会重新遍历fd，判断是否存在就绪的fd。
Select缺点：每次调用select都需要将fd_set从用户态拷贝到内核态，这个开销很大。每次都需要在内核遍历fd，这个开销也很大，select默认只支持1024个文件，描述符。
Epoll:中包含三个操作，epoll_create（新建epoll描述符）, epoll_control（epoll描述符，添加或删除所有待监控的连接）以及epoll_wait返回活跃的连接。epoll_ctrl是不太频繁调用的，epoll_wait是非常频繁调用的。
epoll通过将内核与用户空间mmap（mmap是一种内存映射文件的方法，他能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和虚拟地址空间中一段虚拟地址的一一对应关系，这样方便进程采用指针的方式读写操作这一段内存）。在epoll中mmap将用户空间的一块地址与内核空间的一块地址同时映射到同一块物理内存地址，使得这一块物理内存对内核和用户均可见，减少了用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。红黑树：epoll中使用红黑树来存储epoll所监听的套接字，当添加或删除一个套接字在epoll_ctl上的时候，都在红黑树上处理，红黑树的插入和删除性能好。事件（双向链表）：当事件发生后，回调函数会把这个事件添加到一个双向链表中。因此当调用epoll_wait的时候，只需要检查这个双向链表就可以，效率可观。

