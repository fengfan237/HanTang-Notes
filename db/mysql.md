<br>

<div align="center">
    <img src="logo.jpg" width="200px">
</div>

<br>

1. **MySQL中几种存储引擎简单的介绍和他们之间的区别：**
   **InnoDB:**支持事务，设计目标主要是面向OLTP应用，他的特点是行锁设计，支持外键，它通过使用MVCC来获得高并发性，默认是可重复读级别，但是可以使用next-key locking技术来避免幻读。它存储数据的时候主要采用聚集存储的方式，因此每张表都是按照主键的顺序进行存放的。如果没有人为定义主键，他自己会创建一个rowid，
   **MyISAM:**不支持事务，他是表锁设计，支持全文索引。主要面向OLAP应用，它主要由两部分构成，分别是MYD和MYI。前者负责存储数据，后者用来存放索引文件。
   **Memory：**将所有的数据都存放在内存中，如果数据库重启或者崩溃，表中的数据都会消失，它非常适合存储临时数据的临时表，还有数据仓库中的维度表。它默认使用hash索引。仅支持表锁，并发性能差。
2. MySQL索引：大类主要三种，B+树索引，Hash索引以及支持全文检索的倒排索引。
   B+树索引：聚集索引（一级索引）和辅助索引（二级索引），联合索引，覆盖索引。
   聚集索引与辅助索引的区别：聚集索引汇总的数据页上存放的是完整的每行的记录，而非数据页的索引中，存在的仅仅是键值以及指向数据页的偏移量。我理解的就是辅助索引会再去指向聚集索引。聚集索引数据页之间通过双向链表连接，数据页内的记录也是通过双向链表维护。聚集索引有很大的优势，由于本身数据的存放就是有序的，所以对于排序查找和范围查询有着非常大的优势。
3. **MySQL事务：**主要指的是数据库应该满足ACID四个特性。实现事务的关键技术是，redo log, undo log以及锁。
**Redo:**主要由两部分构成（redo log buffer与redo log file）,它可以保证事务的持久性。在innodb中重做日志以512字节的block存储，与磁盘扇区大小一致。由于innodb是以数据页的形式存储数据，这个redo log存储格式也是基于页的，重做日志格式有很多种，但是有通用的头部格式，redo_log_type,space(表空间ID),page_no(页的偏移量)，之后是redo log body部分。它主要是记录对这个页面的插入，删除之类的操作。例如insert操作，insert into t select 1,1 重做日志大致为page(2,3), offset 32, value 1,2要注意的是同时要对聚集索引和辅助索引都修改，redo log记录的是对页的物理修改操作。如果插入设计B+树的split可能会产生更多的页要被记录下来。
**undo:**主要是为了应对回滚操作，这样当执行的事务由于某种原因失败了，或者用户指定进行rollback的时候就可以利用undo，将数据回滚到修改之前的样子。不同于redo将数据存放在重做日志文件中，undo放在数据库内部的一个特殊段segment中，这个段被称为undo段。undo段位于共享表空间中。要注意的是undo是逻辑日志，而非物理日志，并不是undo就会将数据页恢复到自己修改之前的样子，因为可能还有其他事务再对这个数据页进行修改，如果直接返回当前事务发生前数据页的页面情况，那会把其他事务的修改全部回滚了。因此undo被设计为逻辑日志。我理解的是当innodb回滚的时候，会做与之前的逻辑查询相反的工作，例如之前的insert对应一个delete，之前一个delete对应一个insert这种。事实上，undo另外一个重要的作用是支持MVCC，即innodb中的mvcc实现要通过undo完成，当用户读取一条记录的时候，如果该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此来实现非锁定读取。另外undo log也会产生Redo log，即undo也需要被持久性保护。undo log主要被分为两类：insert undo log和update undo log。insert undo类型的undo log只对事务本身可见，对其他事务不可见，因此这种类型的undo log可以在提交之后直接删除。不需要purge操作。update undo log主要记录delete和update产生的操作，该undo log需要提供mvcc机制，因此不能在事务提交之后就删除，提交后应该放入undo log链表，等待purge线程的判断和删除。
**Purge：**用来完成最终的delete和update操作。这样是合计是因为innodb存储引擎支持mvcc,所以记录不能在事务提交的时候立即处理，因为可能有其他的事务正在处理改行记录，所以innodb存储引擎需要保存记录之前的版本。而是否可以删除该条记录要使用purge进行判断。如果该记录不被任何其他事务引用，就可以真正的执行delete操作。
4. **MySQL锁：**	
Lock与Latch:Latch一般被称为闩锁，因为它要求锁定的时间必须非常短，否则性能会很差，它在mysql中主要指的是mutex(互斥锁)和rwlock（读写锁），主要被用来保证并发线程操作临界资源的正确性，一般没有死锁检测。Lock的对象是事务，主要针对数据库中的对象，例如表，页，行。并且一般lock的对象仅在事务commit或rollback之后进行释放。
MySQL中有粒度锁的概念，从上到下分别是表空间，表，页以及记录。意向锁表达下一行将被请求的锁类型。主要是有对表级别的意向共享锁和意向排它锁。
非锁定读机制（一致非锁定读）：指的是使用MVCC的方式来读取当前数据库中行数据，它不会去等待锁释放之后在读，而是去读取一个快照数据（undo段），读的是历史版本的数据。每行记录可能都有多个版本。看隔离级别决定是读取最新的数据，还是事务开始时候的数据。
一致性锁定读：有select for update和select lock in share mode，前者会对读取的行记录加一个X锁，后者会加S。
行锁的三种算法：recod lock锁住单个行记录（锁主键），Gap Lock（锁间隙），Next-key lock锁住前两者，它可以用来解决幻影读的问题。我理解的就是他的封锁粒度更大，封锁一个查询设计的结果集，禁止其他数据更新操作。
5. **MySQL InnoDB存储引擎架构及内容：**
InnoDB存储引擎主要包含部分：
(1)	多个内存块组成的内存池，负责维护进程线程需要访问的多种内部数据结构，负责缓存磁盘数据，对磁盘数据的修改之前先在这里缓存，重做日志缓冲等。具体来说，缓冲池中缓存的数据类型有：索引页，数据页,undo页，锁信息等。还有LRU List，对上述页进行管理。重做日志缓冲，InnoDB首先将重做日志信息放到这个缓冲区中，之后按照一定频率将其刷新到重做日志文件。
(2)	多个后台线程：主要负责刷新内存池中的数据，保证缓冲池中的内存缓冲是最近的数据，此外要负责将修改过的数据文件刷新到磁盘文件。后台线程主要包括：Master Thread(负责将缓冲池中的数据异步刷新到磁盘，包括脏页的刷新，合并插入缓冲)，IO Thread（处理写IO请求），Purge Thread(回收已经使用并分配的undo页)，page cleaner Thread将脏页的刷新操作放到这里来降低master thread的压力。
(3)	CheckPoint技术：主要是缩短数据库的恢复时间，缓冲池不够用的时候可以将脏页刷新到磁盘，重做日志不可用的时候刷新脏页。主要包含sharp checkpoint与fuzzy checkpoint两种。Sharp checkpoint会在数据库关闭的时候将所有的脏页都刷新到磁盘中，这是默认的。在数据库运行期间一般使用fuzzy checkpoint进行页刷新，即只刷新一部分脏页。
6. **InnoDB中的关键特性：**
**插入缓冲：**通常来说围绕主键的聚集索引在插入的时候是顺序性，而不是离散性的，当然也有可能是离散的。针对InnoDB中其他的非聚集性索引来说，插入通常是离散性并且可能包含重复值，在这种场景下，会导致离散的访问非聚集索引页，这回导致插入效率的大大下降。为了提高非聚集性索引的插入效率，mysql中引入了insert buffer这个概念。它指的是InnoDB中每一次对非聚集性索引的插入和更新操作并不是直接插入到索引页中，而是先判断这个非聚集性索引页是不是存在缓冲池中，如果存在就直接插入，如果不存储在，就先放到一个insert buffer对象中。然后再以一定的频率将insert buffer中的数据和对应的非聚集性索引进行merge。Insert buffer的结构是B+树
两次写：主要是为了提高数据页的可靠性。主要是为了应对部分写失效问题导致的数据丢失情况（一个页面的数据只写了一部分）。直接使用重做日志恢复是不能够的，因为重做日志中记录的是对页的物理操作，例如偏置值多少的时候写入什么记录。但是如果这个页已经发生了损坏，直接redo根本没意义，而是应该将该页恢复到redo之前的状态去再重做才有意义。Double write就是做这个页面的状态恢复的。在将数据写入磁盘之前，先将数据放到内存中的double write buffer中，然后将里面的数据写入到共享表空间中的double write块儿中。之后double write buffer才将page 刷新到数据文件中。
**自适应哈希索引**：它的作用是对缓冲区中的数据页动态的构建。类似于hash double list。
**异步IO：**IO之间不必顺序执行，而是IO请求可以同时发出，优点在于可以考虑merge io，减少io次数，例如几个io读取的是相连的page，那么可以进行io merge。
**刷新邻接页**：主要作用也是实现io merge，即，当刷新一个脏页的时候，会考虑将同一个extent中其他的脏页都刷新到磁盘中去。减少io次数。

7. MySQL 中表的存储：
	索引组织表：InnoDB存储引擎中，表中的数据都是按照逐渐顺序存放的，这种存储方式被称为索引组织表。在InnoDB中要求所有的表都要有一个主键，如果用户没有执行，MySQL首先去判断表中的哪个字段要求unique并且非空，就将它设置为主键，如果没有值符合条件，mysql会自动创建一个6字节大小的指针来充当primary key。
	MySQL表的逻辑存储结构：
		所有的数据都存放在table space中，表空间又可以进一步被细分为segment, extent和page(block)。默认情况下Innodb中所有的表中的数据都存放在默认的共享表空间ibdata1中，但是可以设定每个表拥有一个单独的表空间。表空间中包含段，段中包含区，区中包含一系列的page。而page中的数据是按照row存储的。我主要记住了compact行记录格式：
